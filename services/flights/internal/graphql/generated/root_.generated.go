// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Flight() FlightResolver
	Mutation() MutationResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Flight struct {
		ArrivalTime   func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		DepartureTime func(childComplexity int) int
		Destination   func(childComplexity int) int
		ID            func(childComplexity int) int
		Number        func(childComplexity int) int
		Origin        func(childComplexity int) int
		Status        func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
	}

	Mutation struct {
		CreateFlight func(childComplexity int, number string, origin string, destination string, departureTime time.Time, arrivalTime time.Time) int
	}

	Query struct {
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Flight.arrivalTime":
		if e.complexity.Flight.ArrivalTime == nil {
			break
		}

		return e.complexity.Flight.ArrivalTime(childComplexity), true

	case "Flight.createdAt":
		if e.complexity.Flight.CreatedAt == nil {
			break
		}

		return e.complexity.Flight.CreatedAt(childComplexity), true

	case "Flight.departureTime":
		if e.complexity.Flight.DepartureTime == nil {
			break
		}

		return e.complexity.Flight.DepartureTime(childComplexity), true

	case "Flight.destination":
		if e.complexity.Flight.Destination == nil {
			break
		}

		return e.complexity.Flight.Destination(childComplexity), true

	case "Flight.id":
		if e.complexity.Flight.ID == nil {
			break
		}

		return e.complexity.Flight.ID(childComplexity), true

	case "Flight.number":
		if e.complexity.Flight.Number == nil {
			break
		}

		return e.complexity.Flight.Number(childComplexity), true

	case "Flight.origin":
		if e.complexity.Flight.Origin == nil {
			break
		}

		return e.complexity.Flight.Origin(childComplexity), true

	case "Flight.status":
		if e.complexity.Flight.Status == nil {
			break
		}

		return e.complexity.Flight.Status(childComplexity), true

	case "Flight.updatedAt":
		if e.complexity.Flight.UpdatedAt == nil {
			break
		}

		return e.complexity.Flight.UpdatedAt(childComplexity), true

	case "Mutation.createFlight":
		if e.complexity.Mutation.CreateFlight == nil {
			break
		}

		args, err := ec.field_Mutation_createFlight_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateFlight(childComplexity, args["number"].(string), args["origin"].(string), args["destination"].(string), args["departureTime"].(time.Time), args["arrivalTime"].(time.Time)), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap()
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema.graphqls", Input: `scalar Time

type Mutation {
    createFlight(
        number: String!
        origin: String!
        destination: String!
        departureTime: Time!
        arrivalTime: Time!
    ): Flight!
}

enum FlightStatus {
    SCHEDULED
    DELAYED
    ARRIVED
    IN_PROGRESS
    DEPARTED
    CANCELLED
    UNSPECIFIED
}

type Flight {
    id: ID!
    number: String!
    origin: String!
    destination: String!
    departureTime: Time!
    arrivalTime: Time!
    status: FlightStatus!
    createdAt: Time!
    updatedAt: Time!
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
